\documentclass[]{article}

% Packages
\usepackage{amsmath} % math stuff
%\usepackage[dvipsnames]{xcolor}  % for coloring
\usepackage{tensor}  % tensors, but also for stuff like superscript on the left
\usepackage{enumitem} % for enumerating alphabetically
\usepackage{tabto}		% for tabbing to a certain length
\usepackage{scrextend} % for local margins
\usepackage{titling}	% for subtitle custom command
\usepackage[svgnames, table]{xcolor} % avoid the option clash for hyperref command  + TABLE REP
\usepackage[colorlinks=true, linkcolor=Blue, urlcolor=Blue]{hyperref} % for hyperref command 
\usepackage{pgfplots} % plots
\usepackage{circuitikz} % circuit plots
\usetikzlibrary{positioning} % positioning in circuit plots
\usetikzlibrary{backgrounds, shapes} % shapes for multiplexer+
%%\usepackage{outlines} % convienent itemizing
%%\usepackage{multirow} % multiple rows for tables
\usepackage[at]{easylist}% easy lists with @ starting each item

%for flowchart:
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{siunitx}
\usepackage{tikz}
\usetikzlibrary{patterns}
\usepackage{caption}
\usetikzlibrary{arrows}
\usepackage{color}
\usepackage{pgfplots}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usetikzlibrary{shapes.geometric}
\usepackage{tikz-cd}
\usetikzlibrary{positioning}
\tikzset{
	shift left/.style ={commutative diagrams/shift left={#1}},
	shift right/.style={commutative diagrams/shift right={#1}}
}


%tables for list representation
\usepackage{arydshln, collcell}
\newcolumntype{C}{>{\collectcell\mathsf}c<{\endcollectcell}}

% Python code
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{codeblue}{rgb}{0.08,0.1,0.87}
\lstdefinestyle{pystyle}{
	language=Python,   
	commentstyle=\color{codegreen},
	keywordstyle=\color{codeblue},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}
\lstset{style=pystyle}

%Repeat command
\usepackage{expl3}
\ExplSyntaxOn
\cs_new_eq:NN \Repeat \prg_replicate:nn
\ExplSyntaxOff

% Algorithms
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage[noend]{algpseudocode}
\newcommand{\Get}{\State \textbf{get}~}
\newcommand{\Set}{\State \textbf{set}~}
\newcommand{\Print}{\State \textbf{print}~}
\newcommand{\Getx}[1]{\Statex \algindent{#1} \textbf{get}~}		% x denotes non-numbered lines
\newcommand{\Setx}[1]{\Statex \algindent{#1} \textbf{set}~}	% enter the number of lines to indent
\newcommand{\Printx}[1]{\Statex \algindent{#1} \textbf{print}~}
\newcommand{\Stop}{\State \textbf{stop}~}
\newcommand{\algindent}[1]{\Repeat{#1}{\hskip\algorithmicindent}}
\algdef{SE}[DOWHILE]{Do}{doWhile}{\algorithmicdo}[1]{\algorithmicwhile\ (#1)}


% stop indentation
\setlength{\parindent}{0pt}

% custom subtitle command
\newcommand{\subtitle}[1]{
	\posttitle{
		\par\end{center}
	\begin{center}\large#1\end{center}
	\vskip0.5em}
}


% Fixes weird backwards quote thing
\usepackage [english]{babel}
\usepackage [autostyle, english = american]{csquotes}
\MakeOuterQuote{"}

% fix upside down exclaimation points for less thans or greater thans
\usepackage[T1]{fontenc}

% plots
\usepackage{pgfplots}
\usepgfplotslibrary{fillbetween}
\pgfplotsset{compat=1.15} 


% Title
\title{CS 304 Notes}
\subtitle{Data Structures \& Algorithms}
\author{Jaeden Bardati}
\date{\textit{Last modified \today}}

%\setcounter{section}{-1}	% 0-indexes the section

\begin{document}

\maketitle
\bigbreak

\section{Python and Object-Oriented Programming}
\bigbreak

Python is a \textit{high-level programming language} which makes it useful when studying data structures and algorithms.\\

Python is an \textit{interpreted} language, where \textit{source code} (also referred to as \textit{scripts}), in the form of files with the \textit{.py} suffix, are run by an \textit{interpreter}. It is common to use an integrated development environment (IDE) to aid in displaying and editing Python code. IDEs for Python include the built-in IDLE, PyCharm, Spyder, and others.\\

\subsection{Objects in Python}

Python is an \textit{object oriented} language where \textbf{classes} are the basis of all data types. Examples of data types in Python include int, float, str.\\

An \textbf{assignment statement} assigns an \textbf{identifier} (or name) to an object. Identifiers are associated with a \textit{memory address} and are similar to a pointer in languages such as C++ or Java. For example, the statement 

\begin{lstlisting}[language=Python]
	temp = 98.6
\end{lstlisting}
associates the identifier "temp" to the float value 98.6.\\

Identifiers are \textbf{case-sensitive}. Namely, a variable named "temp" is different than one named "Temp". \\

Python is a \textbf{dynamically typed} language, unlike C++ or Java. That is to say, when making the association of an identifier in Python, the data type is not explicitly declared. In the code above, the data type is determined automatically by the interpreter to be a float.\\

It is possible to establish an \textbf{alias} by assigning a second identifier to an object as follows

\begin{lstlisting}[language=Python]
	temperature = temp
\end{lstlisting}

After an alias is made, either name can be used to refer to the object.\\

The process of creating a class is called \textbf{instantiation}. To do this, we call the \textbf{constructor} of a class. If we have defined the class called Animal then we would do this by

\begin{lstlisting}[language=Python]
	a = Animal()
\end{lstlisting}

Note that we can also pass parameters to the Animal constructor.\\

See Chapters 1 and 2 in the textbook for more.\\


\section{Design and Analysis of Algorithms}
\bigbreak

\subsection{Data structures vs. Abstract Data Types}

There are many \textbf{abstract data types}: list, set, queue, stacks, dictionary, etc.\\

\textbf{Data structures} are the implementation of abstract data types. Examples include: arrays, trees, hash tables, etc.\\

Our goal is to find the best data structure to use. The best data structure is one that minimizes the \textbf{time complexity}. \\

For example, if we have a list $L = [1, 2, 3]$ and we want to insert an element. If we use an array abstract type, then it is easy to write to insert an element at the end of the list, but it is more complicated to insert it at the beginning of the list (must shift all other elements over 1).\\

Another example is the binary search algorithm (e.g. looking for a number in a phone book) has the time complexity of $\theta(log_2n)$.\\

\subsection{Insertion Sort}

The insertion sort algorithm written in pseudocode in Algorithm \ref{alg:insertion-sort-cost}.

\begin{algorithm}[bh!]
	\caption{InsertionSort($A$)}
	\label{alg:insertion-sort-cost}
	\begin{algorithmic}[1]
		\For{($j=2$ to length($A$))}
			\Set key = $A[j]$
			\State // insert $A[j]$ into the
			\State // sorted sequence $A[1..j-1]$
			\Set $i = j - 1$
			\While{($i>0$ and $A[i]>$key)}
				\Set $A[i+1] = A[i]$
				\Set $i = i-1$
				\Set $A[i+1]$ = key
			\EndWhile
		\EndFor
		\Stop
	\end{algorithmic}
\end{algorithm}\bigbreak

We can check the code using a trace for A = [3, 2, 1]. The variables as they change are:\\
\begin{enumerate}
	\itemsep0em
	\item $j = 2$
	\item key = 2
	\item $i = 1$
	\item $A = [3, 3, 1]$
	\item $i = 0$
	\item $A = [2, 3, 1]$
	\item $j = 3$
	\item key = 1
	\item $i = 2$
	\item $A = [2, 3, 3]$
	\item $i = 1$
	\item $A = [2, 2, 3]$
	\item $i = 0$
	\item $A = [1, 2, 3]$
	\item $j = 4$
\end{enumerate}

\subsubsection{Algorithm efficiency}

WE can go line by line through the program and associate an arbitrary time cost as well as a number of times that the line will run. We can represent this in Table \ref{tbl:insertion-sort-cost}. 

\begin{center}
	\begin{table}[h!]\centering
		\caption{Insertion Sort Algorithm Cost}\label{tbl:insertion-sort-cost}
		\begin{tabular}{|c|c|c|}
			\hline
			Line   &Cost   &Times\\\hline
			 1     & $c_1$     & $n$\\
			 2     & $c_2$     & $n-1$\\
			 3     & $0$      & $0$\\
			 4     & $0$      & $0$\\
			 5     & $c_3$     & $n-1$\\
			 6     & $c_4$     & $\sum_{j=2}^n t_j$\\
			 7     & $c_5$     & $\sum_{j=2}^n (t_j-1)$\\
			 8     & $c_6$     & $\sum_{j=2}^n (t_j-1)$\\
			 9     & $c_7$     &$n-1$\\\hline
		\end{tabular}
		\caption*{
			\leftskip2.5cm\relax
			\rightskip2.5cm\relax
			where we let $t_j$ be the number of times that the while loop is executed for a given $j$.
		}
	\end{table}
\end{center}

The time that the algorithm takes is
\begin{equation*}
	T(n) = c_1n+c_2(n-1)+c_3(n-1) + c_4\sum_{j=2}^n t_j + c_5\sum_{j=2}^n (t_j-1) + c_6\sum_{j=2}^n (t_j-1) + c_7(n-1)
\end{equation*}

\underline{\textbf{Best case}}: $t_j$ = 0
$$
T(n) = c_1n + c_2(n-1) + c_3(n-1) + c_4(n-1) + c_8(n-1)
= (c_1+c_2+c_3+c_4+c_8)n - (c_2+c_3+c_4+c_8)
$$

This can be written in the form $an+b$. Namely, the best case is a linear function with $n$.\\

\underline{\textbf{Worse case}}: $t_j = j$ for $j = 2, 3, ... n$, therefore,

\[ \sum_{j=2}^n t_j = \sum_{j=2}^n j = \frac{n(n+1)}{2} - 1 \]

And,

\[\sum_{j=2}^n t_j = \sum_{j=2}^n (j-1) = \frac{n(n-1)}{2}\]

Thus, 

\begin{align*}
	T(n) &= c_1n+c_2(n-1)+c_3(n-1) + c_4\left(\frac{n(n+1)}{2} - 1\right) + c_5\left(\frac{n(n-1)}{2}\right) + c_6\left(\frac{n(n-1)}{2}\right) + c_7(n-1)\\
	&= (\frac{c_4}{2} + \frac{c_5}{2} + \frac{c_6}{2})n^2 + (c_1 + c_2 + c_3 + \frac{c_4}{2} - \frac{c_5}{2} - \frac{c_6}{2} + c_7)n - (c_2 + c_3 + c_4 + c_7)
\end{align*}

This can be written in the form $an^2 + bn + c$. Namely, the worst case is a quadratic function with $n$.\\

\subsection{Asymptotic Analysis}\bigbreak

We say insertion sort has a worst-case running time of $\Theta(n^2)$. All we care about is the order of $n$ as n asymptotically increases without bound. For example, \\

$\frac{n^3}{1000} - 100n^2 - 100n + 3$ has a time complexity of $\Theta(n^2)$.\\

\textbf{Definition:} For a given function $g(n)$ we denote by $\Theta(g(n))$ the set of functions
 
\begin{equation*}
	\Theta(g(n)) \equiv \{f(n): \exists \text{ positive constants } c_1, c_2, n_0 \text{ s.t. } 0 \leq c_1 g(n) \leq f(n) \leq c_2 g(n)~\forall~n \geq n_0\}
\end{equation*}\bigbreak\bigbreak

%\begin{figure}[th!]
%	\centering
%	\begin{tikzpicture}
%		\begin{axis}[
%			axis on top,
%			legend pos=outer north east,
%			axis lines = center,
%			xticklabel style = {font=\tiny},
%			yticklabel style = {font=\tiny},
%			xlabel = Input Size,
%			ylabel = Running Time,
%			legend style={cells={align=left}},
%			legend cell align={left},
%			]
%			\addplot[thin,green,samples=161,domain=0:3.7,name path=f] {2+(x-2)*x*(x-2)};
%			\addplot[very thick,red,samples=161,domain=0:3.7,name path=f] {2+x*(x)/3};
%			\addplot[thin,blue,samples=161,domain=0:3.7,name path=f] {2+x};
%		\end{axis}
%	\end{tikzpicture}
%	\caption{The red line is $g(n)$} \label{fig:theta-efficiency-graph}
%	\bigbreak
%\end{figure}

For all $n \geq n_0$ f(n)  is equal to g(n) within a constant factor. Note that we often abuse the notation and write that $f(n) = \Theta(g(n))$ rather than $f(n) \in \Theta(g(n))$ as one might expect.\\

\textbf{For example}, let us justify that $\frac{n^2}{2} - 3n = \Theta(n^2)$. We must determine positive constants $c_1, c_2, n_0$ s.t. $c_1n^2 \leq \frac{n^2}{2} - 3n \leq c_2 n^2~\forall~n\geq n_0$.\\

Dividing by $n^2$, $c_1 \leq \frac{1}{2} - \frac{3}{n} \leq c_2$, where we choose $c_2 = \frac{1}{2}$, $c_1 = \frac{1}{14}$ for $n_0 \geq 7$. \\

\textbf{Definition:} For a given function $g(n)$, we denote $O(g(n))$ as the set of functions 

\begin{equation*}
	O(g(b)) \equiv \{ f(n): \exists \text{ positive constants } c \text{ and } n_0 \text{ s.t. } 0 \leq f(n) \leq c g(n)~\forall~n \geq n_0 \}
\end{equation*}\bigbreak\bigbreak

We call this "big O" notation. See Figure 3.5 in the textbook for a visualization. It is important to note that if $f(n) = \Theta(g(n))$, then necessarily $f(n) = O(g(n))$. Also note that the $\Omega(g(n))$ notation indicates a minimum asymptotic trend.


\section{Array-Based Sequences}\bigbreak

\subsection{Sequence Types in Python}

The main sequence types in Python are the \textbf{list}, \textbf{tuple} and \textbf{string}. These sequence types can be \textbf{referential} or \textbf{compact}, and \textbf{mutable} or \textbf{immutable}. Referential are distinguished from compact arrays later on in these notes. Mutable arrays are array that can be changes in some way (appended to, values changed, values inserted, etc.), whereas immutable arrays cannot be changed. The following are the properties of the sequence types.

\begin{itemize}
	\item lists are \textit{referential} and \textit{mutable}
	\item tuples are \textit{referential} and \textit{immutable}
	\item strings are \textit{compact} and \textit{immutable}
\end{itemize}

We can do a variety of operations on these sequence types. Some of them include "len(data)", which finds the length of the array data, or "data1 == data2", which checks if the arrays data1 and data2 are equal. See Tables 5.3 and 5.4 from the textbook for a comprehensive list. \\

The non-mutating behaviors are 

\begin{itemize}
	\item len(data): Finds length of array
	\item data[j]: Returns the jth index
	\item data.cout(value): Number of times value is in data
	\item data.index(value): The index of the value in data
	\item Value in data: Same as above
	\item data1 == data2: Checks if the arrays are equal
	\item d2 = data[j:k]: Creates a new array which is a slice from index j (inclusively) to k (exclusively)
	\item d2 = data1 + data2: Creates a new array which is the concatenation of the arrays
	\item d2 = c*data: Creates a new array which is c copies of data
\end{itemize}

and the mutating behaviors are

\begin{itemize}
	\item data[j] = val: Change the value at index j to val
	\item data.append(val): Append to the end of the array
	\item data.insert(k, val): Insert val in an element at index k (increases size)
	\item data.pop(): Removes (and returns) the last element of the array
	\item data.pop(k): Removes (and returns) the kth element of the array
	\item del data[k]: Removes the kth element of the array
	\item data.remove(val): Searches the array for val and removes it
	\item data1.extend(data2): Appends the array data2 to the array data1
	\item data.reverse(): Reverses the order of the array
	\item data.sort(): Sorts the array in increasing order
\end{itemize}

An implementation of data.insert in our previous array class in Python is

\begin{lstlisting}
	def insert (self, k, value):
		if self._n == self._capacity:
			self._resize(2*self._capacity)
		for j in range(self._n, k, -1):
			self._A[j] = self._A[j-1]
		self._A[k] = val
		self._n += 1
\end{lstlisting}

\subsection{Low-Level Arrays}\bigbreak

\subsubsection {What is an Array?}\bigbreak

First, we must define RAM. Random-access memory (RAM) is memory that can be randomly-accessed. Randomly-accessed means that any random element can be accessed just as easily as any other. We can visualize this in a table as follows\\

\begin{table}[H]\centering
	\begin{tabular}{|c|c|c|c|c|c|}\hline
		S & A & M & P & L & E \\\hline
	\end{tabular}\bigbreak
\end{table}

An array is a group of related values sorted one after another in a contiguous portion of RAM. To access an array, we refer to the memory address that the array begins at and add the index. Namely, \\

\begin{lstlisting}
	A[i] = start + index
\end{lstlisting}\bigbreak

\subsubsection{Note for Python Arrays}\bigbreak

Python arrays use pointers to refer to an array in memory. Therefore, we need to explicitly copy an array to make sure it is copied. In the following example, an alias is made and so the sorted array [1, 2, 3] would be outputted.

\begin{lstlisting}
	x = [3, 2, 1]
	y = x
	y.sort()
	print(x)
\end{lstlisting}\bigbreak

\subsubsection{Referential Arrays}\bigbreak
\textbf{Referential Arrays} are arrays that store memory addresses (object references). For example, an array of strings is a referential array because strings are stored as pointers to another location in memory (to a compact array).\\

Let us say that we have an array of primes: 

\begin{lstlisting}
	primes = [2, 3, 5, 7, 11, 13, 17, 19]
\end{lstlisting}\bigbreak

Then, we can create a sub-array with

\begin{lstlisting}
	temp = primes[3:6]
\end{lstlisting}\bigbreak

The array temp is a referential array to a part of the array primes (or rather, to the objects to which the elements reference). See Figure 5.5 in the textbook. If then we set

\begin{lstlisting}
	temp[2] = 15
\end{lstlisting}\bigbreak

Then the temp array at index 15 is now pointing to another location in memory with a new entry 15, but the rest of the array will still point to their original addresses. See Figure 5.6 in the textbook.  \\

If we have an array, 

\begin{lstlisting}
	counters = [0]*8
\end{lstlisting}\bigbreak

This will create an array of \textit{pointers} to the same 0 object. See Figure 5.7 in the textbook. Adding 1 to one of the elements will create a new 1 object and make that element point to it (see Figure 5.8).\\

\subsubsection{Compact Arrays}\bigbreak

\textbf{Compact arrays} are when the elements are stored directly in the array (not an array of pointers). An example of this is a string, with is an array of characters (not pointers of characters). Compact arrays have advantages over referential arrays. Namely, they are good because they\\

\begin{easylist}
	\ListProperties(Style1*=\bfseries,Numbers2=l,Mark1={},Mark2={)},Indent2=1em)
	@ Have less memory usage: No overhead devoted to storage of memory references
	@ Have higher performance:
	@@ direct access
	@@ principle of locality (if we access a certain location in memory, we are likely to access the array again nearby)
\end{easylist}\bigbreak

To use a compact array, we can use the array module. To create one, we must pass a list of a certain type, along with the type code for that type. For a list of signed integers, we use the type code 'i'. For example, we could write

\begin{lstlisting}
	primes = array('i', [2, 3, 5, 7, 11, 13, 17, 19])
\end{lstlisting}\bigbreak

\subsection{Dynamic Arrays and Amortization}\bigbreak

\textbf{Dynamic Arrays} are arrays that can dynamically increase in time. To do this, dynamic arrays reserve a certain amount of space in memory for future appends until it runs out of reserved space, in which case it rewrites the new array along with more reserved space. Python's list class is a dynamic array. We can explore the relation with the code

\begin{lstlisting}
	for k in range(10):
		a = len(data)
		b = sys.getsizeof(data)
		print('Length: {0:3d}; Size in bytes: {1:4d}'.format(a, b))
		data.append(None)
\end{lstlisting}\bigbreak

We can see that the size in memory increases exponentially. This is because the number of spots added is proportional to the size of the array at a time in Python lists. The amount of space that is dynamically added to the array at a time increases as the list grows (it will not always be 4).\\

Let us now implement a dynamic array ourselves

\begin{lstlisting}
	import ctypes
	
	class DynamicArray:
		"""A Dynamic array class akin to a simplified python list"""
		
		def __init__(self):
			"""Create an empty array"""
			self._n = 0
			self._capacity = 1
			self._A = self._make_array(self._capacity)
			
		def __len__(self):
			"""Return number of elements stored in array"""	
			return self._n
			
		def __getitem__(self, k):
			"""Return item at index k"""
			if not 0 <= k < self._n:
				raise IndexError("Invalid index")
			return self._A[k]
		
		def _resize(self, c)
			"""Resize internal array to capacity c"""
			B = self._make_array(c)
			for k in range(self._n):
				B[k] = self._A[k]
			self._A = B
			self._capacity = c
		
		def _make_array(self, c):
			"""Return a new array with capacity c"""
			return (C * ctypes.py_object)()
		
		def append(self, obj):
			"""adds object to end of the array"""
			if self._n == self._capacity:
				self._resize(2*self._capacity)
				self._A[self._n] = obj
				self._n += 1
		
\end{lstlisting}\bigbreak
 
We can test it out using:

\begin{lstlisting}
	arr = DynamicArray()
	arr.append(1)
\end{lstlisting}\bigbreak

We now would like to analyze the efficiency.\\

Reminder: $O(n)$ means \textit{at most} n efficent and $\Omega(n)$ means \textit{at least} n. Here we have $\Omega(n)$ efficiency.\\

Using amortization, we can show that an append is $O(1)$, and n appends are $O(n)$. Namely, a single append does not depend on the size of the array. \\

\textbf{Proposition 5.1:} Let $S$ be a sequence implemented using a dynamic array with initial capacity 1. Using the strategy of doubling the array size when full, the total time to perform $n$ operations is $O(n)$. \\

\textbf{Justification:} Assume 1 cyber-dollar pays for each append where we do not expand array. Assume growing array from size $k$ to $2k$ requires $k$ cyber-dollars. We charge each append 3 cyber-dollars. An overflow occurs when array $S$ has $2^i$ elements for some integer $i \geq 0$ and the size of the array representing $S$ is $2^i$. Namely, doubling the size of the array will cost $2^i$ cyber-dollars. These cyber-dollars can be found in cells $2^{i - 1}$ through $2^i - 1$.\\


\textbf{Proposition 5.2:} Performing a series of $n$ append operations using a fixed increment with each resize takes $\Omega(n^2)$. \\

\textbf{Justification:} Let $c \geq 0$ represent a fixed increment in capacity used for each resize event. During the series of append operations, time will be spent initializing arrays of size $c$, $2c$, $3c$, ..., $mc$ for $m = \frac{n}{2}$. So the overall time is proportional to $c + 2c + 3c + ... + mc = \sum_{i=1}^m ci = c\sum_{i=1}^m i = c\frac{m(m+1)}{2} \geq \frac{\frac{n}{2}\left(\frac{n}{2}-1\right)}{2}$. This is $\Omega(n^2)$.\\


\subsection{Multidimensional Arrays}\bigbreak

If we do

\begin{lstlisting}
	l = [[9]*10]*5
	l[0][3] = 5
\end{lstlisting}

It will change the values of throughout the array. Instead, the correct method to instantiate a multidimensional array is

\begin{lstlisting}
	l = [[9]* 10 for j in range(5)]
	l[0][3] = 5
\end{lstlisting}

This will work by ensuring that they do not all point to the same value.\\


\subsection{Numpy Arrays}\bigbreak

For big data, we can use the NumPy module. We can make an nd-array with 

\begin{lstlisting}
	z = np.zeros((10, 10)) # will create a 10x10 array of 0s
\end{lstlisting}

There are many different methods that NumPy has which are highly optimized in precomplied C-libraries.


\section{Stacks}\bigbreak\bigbreak

The stack is one of the most important and most widely used data structures. Stacks are inserted and removed using the \textbf{last in - first out (LIFO)} principle. \\

Formally, a stack is an ADT (abstract data type) that supports two main methods:

\begin{itemize}
	\item S.push(e): Add e to top of stack
	\item S.pop(): Remove and return top element
\end{itemize}

We can also make it support the following methods:

\begin{itemize}
	\item S.top(): Returns a reference to the top element of the stack
	\item S.is\_empty(): Returns true if empty, otherwise false
	\item len(S): Returns the length of the stack
\end{itemize}

The following table shows an example of these methods in use.

\begin{center}
	\begin{table}[h!]\centering
		\begin{tabular}{|c|c|c|}
			\hline
			Operation   &Return Value   &Stack contents\\\hline
			S.push(5) & None & [5]\\
			S.push(3) & None & [5, 3]\\
			len(S) & 2 & [5, 3]\\
			S.pop() & 3 & [5]\\
			S.is\_empty() & False & [5]\\
			S.pop() & 5 & [~]\\\hline
		\end{tabular}
	\end{table}
\end{center}


We will use the \textbf{adaptor pattern} to construct a stack from the list class using Python.\\

\subsection{Stack Implementation in Python}\bigbreak

 \begin{lstlisting}
 	class ArrayStack:
 		"""LIFO Stack implementation using Python list as underlying shape."""
 		def __init__(self):
 			"""Create an empty Stack """
 			self._data = []
 		
 		def __len__(self):
 			"""Returns length of stack"""
 			return len(self._data)
 			
 		def is_empty(self):
 			"""Return True if stack is empty"""
 			return len(self._data) == 0
 			
 		def push(self, e):
 			"""Adds e to the top of the stack"""
 			self._data.append(e)
 			
 		def top(self):
 			"""Returns the top element"""
 			if self.is_empty():
 				raise EmptyException("Stack is empty")
 			return self._data[-1]
 		
 		def pop(self):
 			"""Removes and returns the top element."""
 			if self.is_empty():
 				raise EmptyException("Stack is empty")
 			return self._data.pop()
 \end{lstlisting}\bigbreak

\subsection{Complexity Analysis}\bigbreak

The following table shows the time complexity of each of these methods.

\begin{center}
	\begin{table}[h!]\centering
		\begin{tabular}{|c|c|}
			\hline
			Operation   & Running Time\\\hline
			S.push(e) & $O(1)$*\\
			S.pop() & $O(1)$*\\
			S.top() & $O(1)$\\
			S.is\_empty() & $O(1)$\\
			len(S) & $O(1)$\\\hline
		\end{tabular}
		\caption*{* means it is amortized.}
	\end{table}
\end{center}\bigbreak

An example of using a stack in Python is the following.

\begin{lstlisting}
	a = [1, 2, 3], S = ArrayStack()
	
	for i in range(len(a)):
		S.push(a[i])
	# S = [1, 2, 3]
	
	while not S.is_empty():
		a[i] = S.pop()
	# a = [1, 2, 3]
\end{lstlisting}\bigbreak

\subsection{Matching Parentheses using a Stack}\bigbreak

In pseudocode, 

\begin{enumerate}
	\item Initialize empty stack
	\item Read characters until end (call current character char)
	\item If char == opening parentheses, push the char to stack
	\item Else If char == closing parentheses and stack is empty, produce error
	\item Otherwise, pop stack and if popped symbol does not match char, produce error
	\item If at EOF (end of file) and stack is not empty, produce error
\end{enumerate}\bigbreak

For example, '(())' would produce no errors. but '(()' would.\\

The Python code for this is

\begin{lstlisting}
	def is_match(expr):
		"""Returns true if all delimiters match"""
		lefty = '([{'
		righty = ')]}'
		S = ArrayStack()
		for c in expr:
			if c in lefty:
				S.push(c)
			elif c in righty:
				if S.is_empty():
					return False
				if righty.index(c) != lefty.index(S.pop()):
					return False
		return S.is_empty()
\end{lstlisting}\bigbreak


\subsection{Polish Notation}\bigbreak

In polish notation, the expression 

\[1 + 2 = 3\]

is written as 

\[1~2~+=3\]

The infix expression 

\[6*(5+(2+3) * 8 + 3) = 288\]

changes its value with a change in the placement of the brackets. However, its polish notation (postfix) equivalent

\[6~5~2~3+8*+~3+*=288\]

does not need that delineation.\\

To evaluate polish notation we
\begin{itemize}
	\item Read expression from left to right
	\item If operand, push to stack
	\item If operator, pop two values off stack, perform operation and push back on stack
\end{itemize}\bigbreak

That is how to evaluate it, but how do we convert between the forms.

\subsubsection{Algorithm for converting infix to postfix}\bigbreak

The steps of the algorithm are
\begin{enumerate}
	\item If operand, place in output
	\item When we encounter an operator, place on stack, also stack left parentheses
	\item If we encounter a right parentheses, pop the stack and write symbols until we encounter a left parentheses
	\item If we see any other symbol (such as +, *, or '('), we pop entries from stack until we find an entry of lower priority
	\item When popping is done, push operator to stack 
	\item If at end, pop entire stack and write it to the output
\end{enumerate}\bigbreak

We can check this with the example\\

Infix: $a + b * c + (d*e + f) * g$\\
Postfix: $abc*+de*f+g*+$\\


\section{Queues}\bigbreak\bigbreak

Queues are \textbf{first-in first-out} (FIFO). For example, waiting in a grocery line is a queue. \\

The basic methods of the queue abstract data class are

\begin{itemize}
	\item Q.enqueue(e): Adds e to the back of the queue.
	\item Q.dequeue(): Removes and returns the first element of queue.
	\item Q.first(): Returns the first element
	\item Q.is\_empty()
	\item len(Q)
\end{itemize}\bigbreak

The following table shows an example of these methods in use.

\begin{center}
	\begin{table}[h!]\centering
		\begin{tabular}{|c|c|c|}
			\hline
			Operation   &Return Value   &Q\\\hline
			Q.enqueue(5) & None & [5]\\
			Q.dequeue(3) & None & [5, 3]\\
			len(Q) & 2 & [5, 3]\\
			Q.dequeue() & 5 & [3]\\
			Q.is\_empty() & False & [5]\\
			Q.dequeue() & 3 & [~]\\\hline
		\end{tabular}
	\end{table}
\end{center}

We can write the queue in terms of the built-in Python list. However doing this as it stands give a dequeue time of $O(n)$, because we would need to swap all the elements down to fill the space.\\

To improve this, we could try setting the first element to None and then have a pointer that moves forward at each dequeue. But this would waste space with a lot of Nones at the beginning of the list. So, we must use circular arrays to avoid this increase in size each dequeue.

A \textbf{circular array} uses the modular arithmetic. In python, this is done using the modulus symbol \%.\\

\begin{lstlisting}
	n = a // b 		# integer division
	m = a % b 		# modulus
	# m = a - b*n is the equivalent expression for m
\end{lstlisting}\bigbreak

We can get the location to insert the next enqueue using

\begin{lstlisting}
	index = (f + size(Q)) % len(Q)
\end{lstlisting}\bigbreak

where $f$ is the pointer location, size(Q) is an arbituary size and len(Q) is the length of the Q.\\

We can then update the pointer with

\begin{lstlisting}
	f = (f + 1) % len(Q)
\end{lstlisting}\bigbreak

An implementation of a queue in Python is

\begin{lstlisting}
	class ArrayQueue:
		"""FIFO Queue using Python List"""
		def __init__(self):
			self._data = [None] * ArrayQueue.DEFAULT_CAPACITY
			self._size = 0
			self._front = 0
			
		DEFAULT_CAPACITY = 10
		
		def __len__(self):
			return self._size
			
		def is_empty(self):
			return self._size == 0
			
		def first(self):
			if self.is_empty():
				raise Exception("List is empty")
			return self._data[self._front]
		
		def dequeue(self):
			if self.is_empty():
				raise Exception("List is empty")
			answer = self._data[self._front]
			
			# circular array implementation
			self._data[self._front] = None 		# to help garbage collect
			self.front = (self._front + 1)% len(self._data)
			
			self._size -= 1
			
			if 0 < self._size < len(self._data)//4:
				# if 25 % of capacity is used, resize to make smaller
				self._resize(len(self._data) // 2)
			return answer
		
		def enqueue(self, e):
			if self._size == len(self._data):
				self._resize(2*len(self._data))
			avail = (self._front + self._size) % len(self._data)
			self._data[avail] = e
			self._size += 1
		
		def _resize(self, cap):
			old = self._data
			self._data = [None] * cap
			walk = self._front
			for k in range(self._size):
				self._data[k] = old[walk]
				walk = (walk + 1) % len(old)
			self._front = 0
\end{lstlisting}\bigbreak 

\subsection{Complexity Analysis}\bigbreak

\begin{center}
	\begin{table}[h!]\centering
		\begin{tabular}{|c|c|}
			\hline
			Operation   & Running Time\\\hline
			Q.enqueue(e) & $O(1)$*\\
			Q.dequeue() & $O(1)$*\\
			Q.first() & $O(1)$\\
			Q.is\_empty() & $O(1)$\\
			len(Q) & $O(1)$\\\hline
		\end{tabular}
		\caption*{* means it is amortized.}
	\end{table}
\end{center}\bigbreak


\section{Linked List}\bigbreak\bigbreak

A linked list is an alternative to an array. There are singly and doubly linked lists.\\

\subsection{Singly Linked List}\bigbreak

A singly linked list is a collection of nodes that form a linear sequence. \\

Each node stores

\begin{itemize}
	\item A reference to an object
	\item A reference to the next node
\end{itemize}\bigbreak

For example, a singly linked list of airports could have a node that points to a flight in Montreal and also points to another flight in Toronto, which also points to Vancouver. \\

The first node of a linked list is called the \textbf{head} and the last node of a linked list is called the \textbf{tail}.\\

Random access in a linked list is quite slow, however, increasing the size is easier, since it is not needed to shuffle all the elements over as you do in an array.\\

To add to the front of the list, we could use the psudeocode:

\begin{lstlisting}
	def add_first(L, e):
		newest = Node(e)
		newest.next = L.head
		L.head = newest
		L.size = L.size + 1
\end{lstlisting}\bigbreak

We can also add to the tail of the list in a similar way.

\begin{lstlisting}
	def add_last(L, e):
		newest = Node(e)
		newest.next = None
		L.tail.next = newest
		L.tail = newest
		L.size = L.size + 1
\end{lstlisting}\bigbreak

To remove the first node, we simply need to set the head to the next one and decrement the size. To remove the tail, we need to set the node before it to None, but that requires iterating through the linked list which is $O(n)$. \\

We can implement a stack using a linked list as the underlying structure.

\begin{lstlisting}
	class LinkedStack:
		"""LIFO Stack implementation using a Linked List"""
		
		class _Node:
			__slots__ = '_element', '_next' 	# optimization for the store of these two fields of the class node
			
			def __init__(self, element, next):
				self._element = element
				self._next = next
			
		def __init__(self):
			self._head = None
			self._size = 0
			
		def __len__(self):
			return self._size
		
		def is_empty(self):
			return self._size == 0
			
		def push(self, e):
			self._head = self._Node(e, self._head)
			self._size += 1
			
		def top(self):
			if self.is_empty():
				raise Exception("Stack is empty")
			self._head._element
		
		def pop(self):
			if self.is_empty():
				raise Exception("Stack is empty")
			answer = self._head._element
			self._head = self._head._next
			self._size -=1
			return answer
\end{lstlisting}\bigbreak

\subsubsection{Complexity Analysis}\bigbreak

\begin{center}
	\begin{table}[h!]\centering
		\begin{tabular}{|c|c|}
			\hline
			Operation   & Running Time\\\hline
			S.push() & $O(1)$\\
			S.pop() & $O(1)$\\
			S.top() & $O(1)$\\
			S.is\_empty() & $O(1)$\\
			len(S) & $O(1)$\\\hline
		\end{tabular}
	\end{table}
\end{center}\bigbreak

Linked stacks are good in real-time applications since no amortization occurs (could happen at a critical time).




\end{document}
