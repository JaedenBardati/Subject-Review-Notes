\documentclass[]{article}

% Packages
%\usepackage[dvipsnames]{xcolor}  % for coloring
\usepackage{titling}	% for subtitle custom command

%for flowchart:
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{siunitx}
\usepackage[a4paper,left=3cm,right=2cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage{tikz}
\usetikzlibrary{patterns}
\usepackage{caption}
\usetikzlibrary{arrows}
\usepackage{color}
\usepackage[colorlinks]{hyperref}
\usepackage{pgfplots}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usetikzlibrary{shapes.geometric}
\usepackage{tikz-cd}
\usetikzlibrary{positioning}
\tikzset{
	shift left/.style ={commutative diagrams/shift left={#1}},
	shift right/.style={commutative diagrams/shift right={#1}}
}


% for code snippets
\usepackage{listings}
\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{frame=none,
	language=Java,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3
}


% Fixes weird backwards quote thing
\usepackage [english]{babel}
\usepackage [autostyle, english = american]{csquotes}
\MakeOuterQuote{"}


% stop indentation
\setlength{\parindent}{0pt}

% fix upside down exclaimation points for less thans or greater thans
\usepackage[T1]{fontenc}

% Custom Commands
\newcommand{\subtitle}[1]{
	\posttitle{
		\par\end{center}
	\begin{center}\large#1\end{center}
	\vskip0.5em}
}

% Title
\title{CS 211 Notes}
\subtitle{Introduction to Programming}
\author{Jaeden Bardati}

\begin{document}

\maketitle
\bigbreak

% Course Video 1
\section{Course Overview\\ {\large \normalfont September 10, 2021}}
\bigbreak

\subsection{Objectives}
\bigbreak

The course is intended to teach how to develop a computer program to solve a problem. C++ is a tools that will be used to develop these skills and logical thinking. These skills will be transferable to other languages.

\section{Computer Organization}
\bigbreak

% Course Video 2
\subsection{Hardware\\ {\large \normalfont September 11, 2021}}
\bigbreak

\subsubsection{Components}
\bigbreak

Modern computers are built using the \textbf{Von Neumann machine}. There are three aspects:

\begin{itemize}
	\item \textbf{Architecture}: \textbf{I/O} (User interaction) + \textbf{Memory} (Storage) + \textbf{CPU} (\textit{CU}: Control Unit, \textit{ALU}: Arithmetic and Logic Unit). These are all connected by a shared bus.
	\item \textbf{Stored Programs}: All programs and data are stored in memory (binary).
	\item \textbf{Sequential Execution}: Also called the \textbf{fetch-decode-execute} cycle. Instructions are \textbf{fetched} from memory, \textbf{decoded} by the CU and then \textbf{executed} by the ALU. If there is a result, it is stored back in memory. \smallskip
\end{itemize}

% Course Video 3
\subsection{Memory\\ {\large \normalfont September 11, 2021}}
\bigbreak

The memory is organized in a \textbf{hierarchy}. At the bottom of the hierarchy is the Hard Drive (in TB). At the top is the CPU. Since the hard drive is slow, when some data from the hard drive is needed, it is first loaded into \textbf{RAM (Random Access Memory)} (in GB). The RAM is still too slow for the RAM, so the data is stored in \textbf{cache} (in KB or MB). Yet still, this is not fast enough for the CPU, so \textbf{registers} (in Bytes) in the CPU itself are used to store variables.

\begin{center}
	\tikzstyle{top} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=purple!30]
	\tikzstyle{medtop} = [rectangle, minimum width=5cm, minimum height=1cm, text centered, draw=black, fill=red!30]
	\tikzstyle{medbot} = [rectangle, minimum width=8cm, minimum height=1cm, text centered, draw=black, fill=orange!30]
	\tikzstyle{bot} = [rectangle, minimum width=12cm, minimum height=1cm, text centered, draw=black, fill=yellow!30]
	
	\begin{tikzpicture}[node distance=2cm, >=latex', auto, thick]
		\node (ntop) [top] {CPU};
		\node (nmedtop) [medtop, below of=ntop] {Cache};
		\node (nmedbot) [medbot, below of=nmedtop] {RAM (Random Access Memory)};
		\node (nbot) [bot, below of=nmedbot] {Hard Drive};
		
		\path[->, shift left=2em]
			(ntop) edge node {store} (nmedtop)
			(nmedtop) edge node {load} (ntop);
		\path[->, shift left=3.5em]
			(nmedtop) edge node {update} (nmedbot)
			(nmedbot) edge node {load} (nmedtop);
		\path[->, shift left=6em]
			(nmedbot) edge node {save} (nbot)
			(nbot) edge node {load} (nmedbot);	
	\end{tikzpicture}
\end{center}
\bigbreak

\noindent As you \textbf{go up} the hierarchy, the \textbf{speed increases}, but the \textbf{size decreases} and the \textbf{cost increases}.

\subsubsection{RAM}
\bigbreak

Random access memory is organized in an array of Bytes ("words"). \\\\
Words in RAM are addressed with a byte themselves (e.g. 01101101 is an address). These are typically written in hexadecimal (e.g. 6D). \\\\
Words in RAM can be data or machine code instructions. Instructions contain a binary code for each operation (for example, addition). Instructions codes are dependent on the CPU.


\section{Computer Organization}
\bigbreak

% Course Video 7
\subsection{A Flow Chart: Program to Binary\\ {\large \normalfont September 12, 2021}}
\bigbreak

This is a flow chart of what is done by the computer when compiling a C++ file. In blue is the Python equivalent.

\begin{center}
	\tikzstyle{greenbox} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=green!30]
	\tikzstyle{bluebox} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=blue!30]
	\tikzstyle{arrow} = [thick,->,>=stealth]
	
	\begin{tikzpicture}[node distance=2cm, >=latex', auto, thick]
		\node (editfile) [greenbox] {Edit file.cpp};
		\node (compile) [greenbox, below of=editfile] {Compile};
		\node (instructions) [greenbox, below of=compile] {Machine Code instructions};
		\node (libraries) [greenbox, left of=compile, xshift=-2cm] {Libraries};
		\node (linker) [greenbox, below of=instructions] {Linker};
		\node (executable) [greenbox, below of=linker] {Executable};
		\node (python) [bluebox, right of=editfile, xshift=2cm] {Python};
		\node (compile2) [bluebox, right of=compile, xshift=2cm] {Compile};
		
		\draw [arrow] (editfile) -- (compile);
		\draw [arrow] (compile) -- (instructions);
		\draw [arrow] (instructions) -- (linker);
		\draw [arrow] (linker) -- (executable);
		\draw [arrow] (libraries) |- (linker);
		\draw [arrow] (python) -- (compile2);
		\draw [arrow] (compile2) |- (instructions);
		\draw [arrow] (compile2) |- (executable);
	\end{tikzpicture}
\end{center}
\bigbreak

\noindent Note that the bottom of the flow chart is the same for all programming languages, because in all languages, CPU-specific machine code is needed to execute code.\\

\noindent The process of catching errors is as according to the following flow chart.

\begin{center}
	\tikzstyle{yellowbox} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=yellow!30]
	\tikzstyle{reddiamond} = [diamond, minimum width=2cm, minimum height=2cm, text centered, draw=black, fill=red!30]
	\tikzstyle{arrow} = [thick,->,>=stealth]
	
	\begin{tikzpicture}[node distance=2cm, >=latex', auto, thick]
		\node (edit) [yellowbox] {Edit};
		\node (compile) [yellowbox, below of=edit] {Compile};
		\node (error) [reddiamond, below of=compile, yshift=-0.4cm] {Error};
		\node (test) [yellowbox, below of=error, yshift=-0.4cm] {Test};
		\node (runtimeerror) [reddiamond, below of=test, yshift=-0.8cm] {Runtime Error};
		\node (useit) [yellowbox, below of=runtimeerror, yshift=-0.8cm] {Use it};
		
		\draw [arrow] (edit) -- (compile);
		\draw [arrow] (compile) -- (error);
		\draw [arrow] (error) -- node[anchor=west] {no} (test);
		\draw [arrow] (test) -- (runtimeerror);
		\draw [arrow] (runtimeerror) -- node[anchor=east] {no} (useit);
		\draw [arrow] (error) -- node[anchor=north, yshift=-0.1cm] {yes} ++(-2.5cm,0) |- (edit);
		\draw [arrow] (runtimeerror) -- node[anchor=north, yshift=-0.1cm] {yes} ++(2.5cm,0) |- (edit);
	\end{tikzpicture}
\end{center}
\bigbreak

\noindent In this context, \textbf{errors} are caught by the compiler. This is opposed to \textbf{runtime errors}, which are not caught by the compiler. These can be something like division by zero or infinite loops.

% Course Video 4, 5, 6 for code blocks setup and first code.
\subsection{First C++ Code\\ {\large \normalfont September 12, 2021}}
\bigbreak

The following code is a hello world program in C++.

\begin{lstlisting}
	// helloworld.cpp
	#include <iostream>		// include statement allows the use of C++ libraries
	#include <stdio.h>		// this library contains getchar()
	
	using namespace std;	// a standard environment (input from keyboard, output is the screen)
	
	int main() {
		
		cout << "Hello world!" << endl;		// Prints "Hello world!" to the screen
		
		getchar();      // wait for user to type a character
		
		return 0;		// 0 means that the execution was successful
	}
\end{lstlisting}
\bigbreak

\subsection{Data types\\ {\large \normalfont September 12, 2021}}
\bigbreak

Variables are referred to as identifiers. Identifiers are memory locations accessed and modified. \\\\
Inside a main function (as above), the following code declares a variable of integer type in C++. 

\begin{lstlisting}
	int numYears;       // allocated space in memory to contain num of years
\end{lstlisting}
\bigbreak

You can also initialize the variable with a value on declaration:
\begin{lstlisting}	
	int number = 5;     // declare and initialize (give a value too)
\end{lstlisting}
\bigbreak

Some rules to follow when naming variables are:
\begin{itemize}
	\item Names have meanings
	\item Must be case sensitive (e.g. numYears is not numyears)
	\item Consists of letters, numbers and underscores
	\item First character cannot be a number
\end{itemize}
\bigbreak

Some types of variables are:
\begin{itemize}
	\item Integers (e.g. -5, 0, +2) [int]
	\item Real numbers (floating point numbers or doubles, e.g. 2.453, -4.1987e7) [float or double]
	\item Booleans (e.g. true, false) [bool]
	\item Characters [char]
\end{itemize}	    
\bigbreak

You can assign a value to a variable after declaring it:
\begin{lstlisting}	
	int width, height;
	int area;
	
	width = 5;
	height = 3;
	
	area = width * height;
\end{lstlisting}
\bigbreak

Constants (denoted with the keyword "const") cannot be changed throughout the program. The convention is to use capital letters for constants.
\begin{lstlisting}	
	const double PI = 3.14159265;

	int radius = 6;
	double area = PI * radius * radius;
\end{lstlisting}
\bigbreak

You would get an error if you were to try to reassign a constant.
\begin{lstlisting}
	const double PI = 3.14159265;
	PI = 3.14; 	/// ERROR
\end{lstlisting}
\bigbreak

\subsection{Arithmetic operations\\ {\large \normalfont September 22, 2021}}
\bigbreak

There are 5 basic arithmetic operations supported by C++
\begin{itemize}
	\item Addition (+)
	\item Subtraction (-)
	\item Multiplication (*)
	\item Division (/)
	\item Modulus or "Remainder" (\%)
\end{itemize}
\bigbreak

For example,

\begin{lstlisting}
	int a = 5;
	int b = 2;
	
	cout << a + b / 2 << endl;			/// 6
	cout << (a + b) / 2 << endl;		/// 3
	cout << a / 2 + 3 << endl;			/// 5
	cout << a / b / 3 << endl;			/// 0
\end{lstlisting}
\bigbreak

This is done with integer operations since both arguments of each operation are integers (round down if the result of a division is a decimal). If one argument is a double/float, the result is a double/float. For example,

\begin{lstlisting}
	int a = 5;
	int b = 2;
	
	cout << a + b / 2 << endl;			/// 6
	cout << (a + b) / 2 << endl;		/// 3.5
	cout << a / 2 + 3 << endl;			/// 5
	cout << a / b / 3 << endl;			/// 0.83333333
\end{lstlisting}

\subsubsection{Assigning and operations}

When you are assigning a variable and performing an operation to it at the same time you can do the following:

\begin{lstlisting}
	int x = 25;
	
	x += 1		// equivalent to x = x + 1
	x -= 2;		// equivalent to x = x - 2
	x *= 3;		// equivalent to x = x * 3
	x /= 4;		// equivalent to x = x / 4
	x %= 5;		// equivalent to x = x / 5
\end{lstlisting}



\subsubsection{Division when initializing or assigning a variable}

Naively, to initialize a variable to the result of a division, you could try

\begin{lstlisting}
	int div = 7/3;		/// 2
\end{lstlisting}
\bigbreak

However, this results in 2, not the desired result of 2.3333. You could also try changing the variable type

\begin{lstlisting}
	double div = 7/3;		/// 2
\end{lstlisting}
\bigbreak

This does not work either, since the integer division happens before the result is assigned to the variable div. Instead, you have to force the compiler to recognize an argument as a float.

\begin{lstlisting}
	double div = 7.0/3;		/// 2.333333
\end{lstlisting}
\bigbreak

If instead you had decided to make the variable type of div and integer and run it

\begin{lstlisting}
	int div = 7.0/3;		/// 2
\end{lstlisting}
\bigbreak

It will perform the double operation, but save it in var as an integer. \\\\

A way of doing the float operation with two integers is by \textbf{casting} types. This can be done as follows.

\begin{lstlisting}
	double div = (double) 7/3;		/// 2.333333
	double div2 = 7/(double)3;		/// 2.333333
	
	int c = 7
	double div3 = (double) c/3;		/// 2.333333
	// Note, this does not change the type of c.
\end{lstlisting}
\bigbreak

The remainder (\%) operation returns the remainder of the division between two integers:

\begin{lstlisting}
	cout << 7 % 3 << endl;		/// 1
	cout << 10 % 6 << endl;		/// 4
	cout << 13 % 4 << endl;		/// 1
\end{lstlisting}

\subsubsection{Type conversion}

We can also convert types from doubles to integers by truncation or rounding: 

\begin{lstlisting}
	double price = 2.55;
	
	int sum = price;		/// truncate
	int sum2 = price + 0.5 	/// round to the nearest int
\end{lstlisting}


\subsection{I/Os\\ {\large \normalfont September 22, 2021}}
\bigbreak


To do this, we will use the iostream library and standard namespace.

\begin{lstlisting}
	#include <iostream>
	using namespace std;
\end{lstlisting}

\subsubsection{Reading inputs}

You can get input from the keyboard using cin. For example,

\begin{lstlisting}
	int number;
	
	cout << "Please enter a value between 0 and 10." << endl;
	
	cin >> number;		// reads integer
	
	cout << "The entered number is " << number;
\end{lstlisting}
\bigbreak

You can also get multiple variables with the same cin.

\begin{lstlisting}
	int length, width;
	
	cout << "Please enter the length and width of the rectangle: ";
	
	cin >> length >> width;
	
	int area = length * width;
	cout << "The area is " << area
\end{lstlisting}
\bigbreak

\subsubsection{Formatting outputs}

When outputting the result of a float, we inevitably run into an issue:

\begin{lstlisting}
	double result = 123456789.1284567;		/// 1.23457e+008
	
	cout << result << endl;
\end{lstlisting}
\bigbreak

This returns 1.23457e+008. To see all the digits, we must first pass result to fixed before cout.
\begin{lstlisting}
	double result = 123456789.1284567;
	
	cout << fixed << result << endl;		/// 123456789.128457
\end{lstlisting}
\bigbreak

To properly format the output of doubles, we must include the iomanip library and use the setprecision(n) function.

\begin{lstlisting}
	#include <iomanip>
	
	double result = 123456789.1284567;
	
	cout << fixed << setprecision(2) << result << endl;		/// 123456789.13
	cout << result << endl;									/// 123456789.13
\end{lstlisting}
\bigbreak

This rounds the double to the nearest nth decimal. Note that result will now format that way if outputted without the fixed and setprecision call. However, this does not actually change the value of the result variable. 

\begin{lstlisting}
	double result2 = result + 1;
	
	cout << setprecision(3) << result2 << endl;			/// 123456790.128
\end{lstlisting}
\bigbreak

Finally, to set a limit to the number of characters that are displayed to an integer n, we can use the setw(n) function from the iomanip library like this

\begin{lstlisting}
	cout << fixed << setprecision(2) << setw(15) << left << result << "End of line" << endl;
\end{lstlisting}
\bigbreak

The result is "123456789.13~~~End of line". Note the exactly 15 characters until "End of line".

\subsection{Strings\\ {\large \normalfont September 22, 2021}}
\bigbreak

To use strings, you have to include the string library:

\begin{lstlisting}
	#include <string>
\end{lstlisting}

\subsubsection{Declaration}

You can declare, initialize, assign, and output strings as such
\begin{lstlisting}
	string lname;
	string fname = "Jaeden";
	lname = "Bardati";
	
	cout << fname << " " << lname;		/// Jaeden Bardati
\end{lstlisting}

\subsubsection{Concatenation}

To combine strings together, we must use \textbf{concatenation}.
\begin{lstlisting}
	string name = fname + " " + lname;		/// Jaeden Bardati
\end{lstlisting}
\bigbreak

This method does not work for constants
\begin{lstlisting}
	string greeting = "Hello" + " " + " World";		/// ERROR
\end{lstlisting}
\bigbreak

An error occurs because we are trying to add the string " " to the constant string "Hello". A way to get around this is by adding a dummy variable before the concatenation.
\begin{lstlisting}
	string empt; 		// empt = ""
	string greeting = empt + "Hello" + " " + " World";		/// Hello World
\end{lstlisting}

\subsubsection{Inputting strings}

To read in a string, we can naively try

\begin{lstlisting}
	string myname;
	
	cin >> myname;		/// Jaeden Bardati
	
	cout << myname;		/// Jaeden
\end{lstlisting}
\bigbreak

Only one word at a time is read in because cin treats things separated by spaces as distinct.

\begin{lstlisting}
	string myname;
	string myfname, mylname;
	
	cin >> myfname >> mylname;				/// Jaeden Bardati
	
	myname = myfname + " " + mylname;
	
	cout << myname << endl;					/// Jaeden Bardati
\end{lstlisting}

\subsubsection{String functions}

A useful quantity to know for a given string could be its length. You can get it as follows

\begin{lstlisting}
	int n = myname.length();
	
	cout << "Your name has " << n-1 << " characters" << endl;
\end{lstlisting}
\bigbreak

Here the number of characters is $n - 1$ since the space is not included.\\\\

You can also get substrings using substr($i$, $n$) to get the $n$ characters proceeding the character at location $i$. If only $i$ in entered, it will extract all characters preceding the character at location $i$.

\begin{lstlisting}
	string sub = myname.substr(0, 6);		/// Jaeden
	string sub2 = myname.substr(7);			/// Bardati
\end{lstlisting}


\subsubsection{Characters}

Characters are strings of length 1, however, they can be declared explicitly with the char keyword and are expressed using single quotes.

\begin{lstlisting}
	char c = 'Y';
\end{lstlisting}


\subsection{The If Statement\\ {\large \normalfont September 23, 2021}}
\bigbreak

We can also use conditional statements.

\subsubsection{Flow Chart}
\bigbreak

\begin{center}
	\tikzstyle{greenbox} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=green!30]
	\tikzstyle{greendiamond} = [diamond, minimum width=2cm, minimum height=2cm, text centered, draw=black, fill=green!30]
	\tikzstyle{arrow} = [thick,->,>=stealth]
	
	\begin{tikzpicture}[node distance=2cm, >=latex', auto, thick]
		\node (code) [greenbox] {Code};
		\node (condition) [greendiamond, below=1cm of code] {Condition};
		\node (statement1) [greenbox, below left=1cm of condition] {Statement 1};
		\node (statement2) [greenbox, below right=1cm of condition] {Statement 2};
		\node (latercode) [greenbox, below=2cm of condition] {More Code};
		
		\draw [arrow] (code) -- (condition);
		\draw [arrow] (condition) -| node[anchor=south west] {True} (statement1);
		\draw [arrow] (condition) -| node[anchor=south east] {False} (statement2);
		\draw [arrow] (statement1) |- (latercode);
		\draw [arrow] (statement2) |- (latercode);
	\end{tikzpicture}
\end{center}
\bigbreak

\subsubsection{Syntax}
\bigbreak

The if statement has the syntax

\begin{lstlisting}
	if (condition)
		statement1;
	else
		statement2;
\end{lstlisting}
\bigbreak

Or, if there is no second statement, simply

\begin{lstlisting}
	if (condition)
		statement1;
\end{lstlisting}
\bigbreak

For multiple statements, we can use parentheses

\begin{lstlisting}
	if (condition) {
		statement;
		statement;
		...
	}
	else {
		statement;
		statement;
		...
	}
\end{lstlisting}
\bigbreak


\subsubsection{The condition}
\bigbreak

A condition is a \textbf{boolean expression}. A boolean type can be \textbf{true} or \textbf{false}.\\

Boolean expressions are written using \textbf{relational operators}:

\begin{center}
	\begin{tabular}{rl}
		< & Less than \\
		> & Greater than\\
		<= & Less than or equal\\
		>= & Greater than or equal\\
		== & Equal to\\
		!= & Not equal to\\
	\end{tabular}
\end{center}

You can also chain relational operators with \textbf{logic operators}:\\
\begin{center}
	\begin{tabular}{rl}
		|| & OR \\
		\&\& & AND \\
		! & NOT \\
	\end{tabular}
\end{center}

For example,

\begin{lstlisting}
	if (num < 20 || num % 3 == 1)	// if num is < 20 or if the remainder of num / 3 is 1
		num = num * 2
	else
		num = num / 2
\end{lstlisting}
\bigbreak

\subsubsection{Floating point precision error}

Let us show an example of a floating point precision error. Note that here we are including the cmath library.

\begin{lstlisting}
	double root, number;
	
	root = sqrt(3);
	number = pow(root, 2);
	
	cout << setprecision(18) << "Number is : " << number << endl;	// 2.999999999999999956, not 3
	
	if (number == 3)
		cout << "sqrt(3) * sqrt(3) = 3" << endl;
	else
		cout << "What just happened?" << endl;
\end{lstlisting}
\bigbreak


When running this in a main function, we obtain the "What just happened?" result. What just happened indeed? The issue is that floating point numbers are only precise to a certain number of digits. To account for this, we must set our own precision as follows:

\begin{lstlisting}
	double precision = 1E-14;
	
	if (abs(number - 3) < precision)
		cout << "sqrt(3) * sqrt(3) = 3" << endl;
	else
		cout << "What just happened?" << endl;
\end{lstlisting}
\bigbreak
 
 This returns the desired result of "sqrt(3) * sqrt(3) = 3".\\
 

\subsubsection{String comparison (alphabetical order)}

We can also use comparison operators for strings. For example,

\begin{lstlisting}
	string name1, name2;
	
	cin >> name1 >> name 2;
	
	if (name1 < name2)
		cout << name1 << endl << name2;
	else
		cout << name2 << endl << name1;
\end{lstlisting}
\bigbreak

This will return two entered strings in alphabetical order.


\subsubsection{Nested ifs}


Sometimes there are more than one options. To do this we can use nested ifs. You check conditions within conditions for multiple branchings.

For example, we can assign a letter grade for a given percentage grade. 

\begin{center}
	\begin{tabular}{rl}
		A & 80 <= grade <= 100 \\
		B & 65 <= grade < 80 \\
		C & 50 <= grade < 65 \\
		F & 0 <= grade < 50 \\
	\end{tabular}
\end{center}

The implementation of this in code is

\begin{lstlisting}
	int grade;
	char letter;
	
	cout << "Please enter a numeric grade: ";
	cin >> grade;
	
	if (grade >= 50)
		if (grade >= 65)
			if (grade >= 80)
				letter = 'A';
			else
				letter = 'B';
		else
			letter = 'C';
	else
		letter = 'F';
		
	cout << "The letter grade is " << letter << endl;
\end{lstlisting}
\bigbreak








\end{document}
