\documentclass[]{article}

% Packages
%\usepackage[dvipsnames]{xcolor}  % for coloring
\usepackage{tensor}  % tensors, but also for stuff like superscript on the left
\usepackage{enumitem} % for enumerating alphabetically
\usepackage{tabto}		% for tabbing to a certain length
\usepackage{scrextend} % for local margins
\usepackage{titling}	% for subtitle custom command
\usepackage[svgnames]{xcolor} % avoid the option clash for hyperref command 
\usepackage[colorlinks=true, linkcolor=Blue, urlcolor=Blue]{hyperref} % for hyperref command 

% Algorithms
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage[noend]{algpseudocode}
\newcommand{\Get}{\State \textbf{get}~}
\newcommand{\Set}{\State \textbf{set}~}
\newcommand{\Print}{\State \textbf{print}~}
\newcommand{\Stop}{\State \textbf{stop}~}
\algdef{SE}[DOWHILE]{Do}{doWhile}{\algorithmicdo}[1]{\algorithmicwhile\ (#1)}

% stop indentation
\setlength{\parindent}{0pt}

% custom subtitle command
\newcommand{\subtitle}[1]{
	\posttitle{
		\par\end{center}
	\begin{center}\large#1\end{center}
	\vskip0.5em}
}


% Fixes weird backwards quote thing
\usepackage [english]{babel}
\usepackage [autostyle, english = american]{csquotes}
\MakeOuterQuote{"}

% fix upside down exclaimation points for less thans or greater thans
\usepackage[T1]{fontenc}


% Title
\title{CS 201 Notes}
\subtitle{Introduction to Computer Science}
\author{Jaeden Bardati}
\date{\textit{Last modified \today}}

\setcounter{section}{-1}	% 0-indexes the section

\begin{document}

\maketitle
\bigbreak

% Course Video 0
\section{Course Overview\\ {\large \normalfont September 10, 2021}}
\bigbreak

\subsection{What is Computer Science?}
\bigbreak

Computer science is the study of \textbf{algorithms}.\\\\
An \textbf{algorithm} is an effective method for solving a problem, expressed as a finite sequence of steps.\\\\
The development of algorithms works in this recurring order:
\begin{itemize}
	\item \textbf{Design}
	\item \textbf{Analysis}
	\item \textbf{Implement}
	\item \textbf{Experiment}\smallskip
\end{itemize}

\noindent In the \textbf{design} phase, we design an algorithm using pseudo-code. In the \textbf{analysis} phase, we need to analyze the correctness and the efficiency. That is to say, we make sure that our algorithm will work and completes in a reasonable amount of time. During the \textbf{implementation}, the algorithm is written in code on a computer. Finally, the algorithm is run and debugged in the \textbf{experiment} phase. This process repeats.


\section{Introduction to Algorithms}
\bigbreak

% Course Video 1
\subsection{Design\\ {\normalfont September 11, 2021}}
\bigbreak

An algorithm is a step by step procedure to solve a problem. For example, 
\begin{itemize}
	\item Step 1: Do something
	\item Step 2: Do something
	\item ...
	\item Step n: Do something\smallskip
\end{itemize}

\noindent There are three basic types of steps. Note that there is a fourth (recursion), but it is not covered in this course. 
\subsubsection{Sequential Steps}
\bigbreak
	\textbf{Do a single task}.\\\\
	\textit{For example:} Let $x$ be a variable. A sequential step could be to add 1 to $x$.
\subsubsection{Conditional Steps}
\bigbreak
	\textbf{Ask a question} that supports only \textbf{logic answers} (true or false answer). \\\\
	\textit{For example:} Let $x$ be a variable. A conditional step could be to ask if $x > 0$. If so, add 1 to $x$; otherwise, subtract 1 from $x$.
\subsubsection{Iterative Steps (loops)}
\bigbreak
	\textbf{Repeat a task} until a certain condition is satisfied. This step links the sequential step to the conditional steps.\\\\
	\textit{For example:} If you have a recipe that you need to add water until its dry. An iterative step would be one where you add $\frac{1}{2}$ cup to mixture while mixture is dry.


% Course Video 2 and 3
\subsection{Case Study: Addition Algorithm\\ {\normalfont September 11, 2021}}
\bigbreak

Let's say we want to add 472 to 593. We would to it like so:\\\\
\begin{tabular}{cccc}
	& \tiny 1 & \tiny & \tiny \\
	& 4 & 7 & 2 \\
	+ & 5  & 9 & 3 \\
	\hline
	1 & 0 & 6 & 5 \\
\end{tabular}
\medbreak
\noindent If you know how to add these numbers, you know how to do it for any numbers. Why? Because we used a sequence of steps to solve it: We used an algorithm. What is this algorithm?\\

\noindent We know that we can break down the work for each of the digits. It is an iterative statement for each digit. What is the work we need to do at each iteration?\\

\noindent First, we add the digits plus the carry in (starts at 0). This is a \textbf{sequential step}. Then, we ask if it is greater than 9. If so, we set the resulting digit as the addition subtracted by 10 and set the carry out (which is te carry in for the next step) to 1; otherwise, we simply set the resulting digit as the addition and set the carry out to be 0. This is a \textbf{conditional step}. Then we repeat this process until we have no more digits to add. This is an \textbf{iterative step}.\\

\noindent Now, we need to conceptualize this. Let's let $m \geq 1$ be the number of digits. Let us define $a_i$ (first number digits), $b_i$ (second number digits) and $c_i$ (resulting number digits) as follows:

\begin{tabular}{ccccc}
	& \tiny & \tiny & \tiny & \tiny \\
	& $a_{m-1}$ & ... & $a_{1}$ & $a_{0}$ \\
	+ & $b_{m-1}$ & ... & $b_{1}$ & $b_{0}$ \\
	\hline
	$c_{m}$ & $c_{m-1}$ & ... & $c_{1}$ & $c_{0}$ \\\smallskip
\end{tabular}

\noindent Let's write the steps of our algorithm:

\begin{algorithm}
	\caption{\\Addition Algorithm}
	\begin{algorithmic}[1]
		\Get $m$ (provided by user)
		\Get $a_{m-1}$, ...  $a_{1}$, $a_{0}$ and $b_{m-1}$, ...  $b_{1}$, $b_{0}$ (provided by user)
		\Set $i = 0$ (digit index) and carry = 0
		\While{($i \leq m - 1$)}
			\Set $c_i = a_i + b_i$ + carry
			\If{($c_i \geq 10$)}
				\Set $c_i = c_i - 10$
				\Set carry = 1
			\Else
				\Set carry = 0
			\EndIf
			\Set $i = i + 1$
		\EndWhile
		\Set $c_m$ = carry
		\Print $c_{m-1}$, ...  $c_{1}$, $c_{0}$
		\Stop
	\end{algorithmic}
\end{algorithm}

\noindent This can be programmed now using a programming language.\\

\noindent If you want to test your algorithm, you can perform a \textbf{trace}. A trace is when you go through the algorithm yourself step by step for a test case.


% Course Video 4, 5, 6 and 7
\subsection{Pseudocode\\ {\normalfont September 11, 2021}}
\bigbreak

Pseudocode is:

\begin{itemize}
	\item Simplified
	\item A tradeoff between natural and programming languages
	\item Not unique\smallskip
\end{itemize}

\noindent We will now look into the types of statements and the syntax we will use.

\subsubsection{Sequential statements}
\bigbreak
\begin{itemize}
	\item \textbf{Input}: Get "variable". E.g. Get $m$, Get radius
	\item \textbf{Computation}: Set variable = expression. E.g. Set area = $\pi \times$ radius$^2$
	\item \textbf{Output}: Print "variable". E.g. Print area.\smallskip
\end{itemize}

\begin{algorithm}
	\caption{\\Calculates the average of three numbers.}
	\begin{algorithmic}[1]
		\Get $x, y, z$
		\Set average = $\frac{x + y + z}{3}$
		\Print average
		\Stop
	\end{algorithmic}
\end{algorithm}

\subsubsection{Conditional statements}
\bigbreak
\begin{itemize}
	\item If (condition) Then\\
				\tabto{0.5cm}operation T$_1$\\
				\tabto{0.5cm}operation T$_2$\\ 
				\tabto{0.5cm}...\\
				\tabto{0.5cm}operation T$_\mathrm{m}$\\
			Else\\
				\tabto{0.5cm}operation F$_1$\\
				\tabto{0.5cm}operation F$_2$\\ 
				\tabto{0.5cm}...\\
				\tabto{0.5cm}operation F$_\mathrm{n}$\smallskip
\end{itemize}

\begin{algorithm}
	\caption{\\Print average of three number if the first number is larger than 0, otherwise print an error message.}
	\begin{algorithmic}[1]
		\Get $x, y, z$
		\If{($x \geq 0$)}
			\Set average = $\frac{x + y + z}{3}$
			\Print average
		\Else	
			\Print "Bad Data"
		\EndIf
		\Stop
	\end{algorithmic}
\end{algorithm}

\noindent When a conditional statements within a conditional statement it is called a \textbf{nested} conditional statements (or nested ifs). This also applies to nested iterative statements (or nested loops).


\subsubsection{Iterative statements}
\bigbreak
\begin{itemize}
	\item While (condition) Do step $i$ to step $j$ \setlength{\itemindent}{0.5cm}
		\item Step $i$: operation
		\item Step $i + 1$: operation
		\item ...
		\item Step $j$: operation
	\setlength{\itemindent}{0cm}\item Stop\smallskip
\end{itemize}

\noindent There are some considerations that you have to be careful of when writing a while loop:\\
\begin{addmargin}[2em]{0em}
	If the condition is initially false, the loop will not execute at all.\\\\
	If the condition is initially true, the loop is iterated until the condition is false. This means that \textit{at least one step should change the condition at some point}. If this is forgotten, the loop will run forever (called an \textbf{infinite loop})! This is considered a \textbf{fatal error}.\\
\end{addmargin}


\begin{algorithm}
	\caption{\\Compute and print the square of the first 100 integers.}
	\begin{algorithmic}[1]
		\Set index=1
		\While{(index $\leq$ 100)}
			\Set square = index * index
			\Print square
			\Set index = index + 1
		\EndWhile
		\Stop
	\end{algorithmic}
\end{algorithm}


% Course video 8
\subsubsection{The Do-While\\ {\normalfont September 23, 2021}}
\bigbreak

The do-while is similar to the while-do, but you check the condition after the do section.

\begin{itemize}
	\item Do \setlength{\itemindent}{0.5cm}
	\item Step $i$: operation
	\item Step $i + 1$: operation
	\item ...
	\item Step $j$: operation
	\setlength{\itemindent}{0cm}\item While (condition)\smallskip
\end{itemize}

This will always execute at least once. It will only execute once if the condition is false, and multiple if it is true. For example,

\begin{algorithm}
	\caption{\\Read a var $x$, print $\sqrt{x}$ and repeat the process as long as requested by user.}
	\begin{algorithmic}[1]
		\Get $x$
		\Do
			\Get $x$
			\If{($x \geq 0 $)}
				\Set root = $\sqrt{x}$
				\Print root
			\Else
				\Print "Bad data"
			\EndIf
			\Print "Do you want to continue? Y/N"
			\Get continue
		\doWhile{continue == 'Y'}
		\Stop
	\end{algorithmic}
\end{algorithm}


% Course video 9 and 10
\subsection{The Sequential Search Algorithm\\ {\normalfont September 24, 2021}} \label{sequentialsearchalgorithm}
\bigbreak

Given a dataset of a given size $N$ and given a target, is the target in the dataset?\\

For example, if the dataset is the list [13, 4, 5, -20, 45, 112] with $N = 6$. Is the target 45 in the dataset? Yes. Is the target 130 in the dataset? No. \\

To solve for much larger values of N, we can search sequentially through the list until we reach the target (the target is in the list), or the end of the list (the target is not in the list).\\

Let us assume we have a list of size $N$ whose elements are $L_1$, $L_2$, ..., $L_N$ and a target element called Target.

\begin{algorithm}
	\caption{\\Sequential Search Algorithm}
	\begin{algorithmic}[1]
		\Get $L_1$, $L_2$, ..., $L_N$, $N$, Target
		\Set Found = No
		\Set $i$ = 1
		\While{Found = No AND $i$ <= $N$}
			\If{($L_i$ == Target)}
				\Set Found = Yes
			\Else
				\Set $i$ = $i$ + 1
			\EndIf
		\EndWhile
		\If{Found = Yes}
			\Print "Target in list."
		\Else
			\Print "Target not in list."
		\EndIf
		\Stop
	\end{algorithmic}
\end{algorithm}

% Course video 12 and 13 (what happened to 11?... no clue, probably best not to ask)
\subsection{Find Largest\\ {\normalfont September 25, 2021}}
\bigbreak

Given a list of $N$ elements, what is the largest element in the list?\\

For example, if the list is [19, 41, 12, 63, 22] with $N = 5$. Each element has an index (1, 2, 3, 4, and 5, respectively). The largest element is 63.\\

To solve, we can store a value for the largest value starting with the first number and then iterate through each other element of the list and update the largest number to the current element if it is larger than the stored value for the largest element.\\

Let us assume we have a list of size $N$ whose elements are $L_1$, $L_2$, ..., $L_N$.

\begin{algorithm}
	\caption{\\Find Largest}
	\begin{algorithmic}[1]
		\Get $N$, $L_1$, $L_2$, ..., $L_N$
		\Set $i$ = 2
		\Set largest = $L_1$
		\Set index = 1
		\algstore{findlargest}
	\end{algorithmic}
\end{algorithm}
\begin{algorithm}
	\begin{algorithmic}[1]
		\algrestore{findlargest}
		\While{$i$ <= $N$}
			\If{($L_i$ > largest)}
				\Set largest = $L_i$
				\Set index = $i$
			\EndIf
			\Set $i$ = $i$ + 1
		\EndWhile
		\Print largest
		\Stop
	\end{algorithmic}
\end{algorithm}


% Course video 14
\subsection{The Swap Algorithm\\ {\normalfont September 25, 2021}}
\bigbreak

Assume we have two variables $x$ and $y$ and want to swap them. Let us say, $x = 5$ and $y = 5$. After the swap we want $x = 3$ and $y = 5$.\\

To do this, we could try simply setting $x = y$ and then $y = x$. Doing this would simply make $x = y = 3$. Thus, we need a temporary variable to store the value of $x$ in during the swap.

\begin{algorithm}
	\caption{\\Swap(x, y)}
	\begin{algorithmic}[1]
		\Require $x$, $y$
		\Set temp = $y$
		\Set $y$ = $x$
		\Set $x$ = temp
	\end{algorithmic}
\end{algorithm}


% Course video 15
\subsection{The Gauss Sum\\ {\normalfont September 25, 2021}}
\bigbreak

Gauss was a mathematician who came up with a method to do the following. Let's assume $n > 1$. We want to find the result of the sum = 1 + 2 + 3 + ... + $n$. For $n = 5$, then sum = 1 + 2 + 3 + 4 + 5 = 15.

\begin{algorithm}
	\caption{\\Gauss Sum}
	\begin{algorithmic}[1]
		\Get $n$
		\Set sum = 0
		\Set $i$ = 1
		\While{($i \leq n$)}
			\Set sum = sum + $i$
			\Set $i$ = $i + 1$
		\EndWhile
		\Print sum
		\Stop
	\end{algorithmic}
\end{algorithm}


Gauss, however, noticed that sum = $\frac{n(n+1)}{2}$. For $n = 5$, sum = $\frac{5(5+1)}{2} = 15$. This makes the algorithm much faster.


% Course video 16
\subsection{Algorithms Efficiency (Complexity)}
\bigbreak

An algorithm is \textbf{efficient} if it uses the smallest number of steps to solve the problem. What we are really interested in is how well the algorithm \textit{scales} with large datasets. \\

For example, assume the size of the data is $n$ and two correct algorithms. \\ 

Algorithm 1 is 20 steps. \par 
Algorithm 2 is 15 steps. \\

Which is the best algorithm? You might think that the best algorithm is the one that uses 15 steps. You are probably wrong.\\

Why? When we refer to "steps" in the algorithmic efficiency definition, we really mean the number of CPU operations not the number of steps written in the algorithm. We could have a loop that causes the algorithm to run much longer than one without a loop. So the number of steps in the written algorithm is not a good measure of efficiency.\\

Assume we have some arbitrary algorithm for a dataset of size $n$ with a loop and some sequential steps. 

\begin{itemize}
	\item $n$ small ---------------------------------> very large $n$
	\item Sequential statement ---------------> Cost is the same
	\item Conditional statement --------------> Cost is the same
	\item Iterative statement ------------------> Cost increases
\end{itemize}

Thus, \textbf{efficiency} is related to the loops in the algorithm. When we say \textbf{efficiency analysis}, we really mean \textit{loop analysis}.


% Course video 17
\subsubsection{Case Study: Sequential Search\\ {\normalfont October 5, 2021}}
\bigbreak

We will analyze the efficiency of the \hyperref[sequentialsearchalgorithm]{Sequential Search Algorithm}. \\

\textbf{Best case scenario:} The algorithm will stop immediately. The number of iterations is 1.\\

\textbf{Worse case scenario:} The algorithm will go through all elements before stopping. The number of iterations is $n$.\\

\textbf{Average case scenario:} The target has an equal likelihood to be in any location (1, 2, 3, 4, ..., n). The average is therefore $\frac{1+2+3+4+...+n}{n}$. This is a Gauss sum which equals $\frac{(n+1)n}{2n} = \frac{n+1}{2}$. Thus, the average case scenario has a number of iterations $\frac{n+1}{2}$.\\


We will now do a \textbf{time analysis:}\\

Assume that the time required for 1 iteration is $C$ (depending on the computer).\\








\end{document}
